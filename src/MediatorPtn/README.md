# Mediator 패턴

## mediator패턴이란?
mediator는 조정자, 중재자라는 의미. 이 패턴에선 '중개인'에 가까움. 중개인은 여러사람들사이에 서서 일을 보고받고 지시, 주선하는 역할을 함. mediator패턴의 중개인도 여러 클래스들 사이를 중개하고 보고를 한곳에 받아 일을 지시하는 역할을 함. 

## mediator패턴의 구성
- Mediator: colleague역할과 통신하여 조정을 실행하기 위한 인터페이스를 결정
- ConcreteMediator: mediator를 구현한 클래스.
- Colleague: mediator역할과 통신을 실행할 인터페이스를 결정
- concreteColleague: colleague를 구현한 클래스.

## 왜필요함?

### 로직의 분산을 줄임
예제의 LoginFrame에 있는 colleagueChanged()는 colleague에서 변경이 일어나는 이벤트가 일어났을때 각 view를 활성화/비활성화 하는 로직을 담당함. textfield, button, checkbox 각각에서 이벤트가 일어나지만 그 이벤트에 대한 처리는 한곳에서 담당함으로써 해당 로직에 문제가 발생시 디버깅하기가 쉬워짐. 이는 이전에 배웠던 로직을 분산하는 거랑 좀 반대되는 경우임. 때에따라서 일을 분할해서 처리(각 클래스는 자신의 일,로직만 담고있음)해야하는 경우도 있고 이렇게 여러군데와 얽힌 로직을 한곳에 모아서 처리하는게 좋을때도 있음. 이경우가 바로 그 경우임.

### 여러객체간 통신경로를 단순화
예제의 기능(다른 컴포턴트의 값이 다른 컴포넌트의 상태에 영향을 줌)을 구현하기 위해선 각 컴포넌트가 서로 통신해야함. 이런 상황에서 mediator패턴을 적용하지 않으면 각 컴포넌트끼리 직접 통신하는 인터페이스를 만들어야함. 이는 서로 통신해야하는 객체 수가 적으면 문제없지만 객체가 많아질수록 프로그램이 점점 복잡해짐. 

## ConcreteMediator는 의존성이 높음
concreteColleage는 재이용하기 쉽지만 concreteMediator는 재이용하기 어려움. mediator는 분산된 로직을 한데 모아 로직을 단순화하는 장점이 있지만 그만큼 어플리케이션에대한 의존도가 높음. 따라서 concreteMediator를 재사용하기 어려움. 